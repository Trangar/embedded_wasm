mod execute;
mod parse;
mod types;

pub use self::{execute::*, parse::*, types::*};

use crate::Vec;

// TODO: Organize these based on the order of chapter 2.4
// TODO: Copy documentation from chapter 2.4 to the relevant instructions
#[derive(Clone, Debug, PartialEq)]
pub enum Instruction {
    // 5.4.1 Control instructions
    Unreachable,
    Nop,
    Block {
        bt: BlockType,
        inner: Vec<Instruction>,
    },
    Loop {
        bt: BlockType,
        inner: Vec<Instruction>,
    },
    If {
        bt: BlockType,
        inner: Vec<Instruction>,
    },
    IfElse {
        bt: BlockType,
        if_inner: Vec<Instruction>,
        else_inner: Vec<Instruction>,
    },
    Branch {
        index: LabelIdx,
    },
    BranchIf {
        index: LabelIdx,
    },
    BranchTable {
        labels: Vec<LabelIdx>,
        index: LabelIdx,
    },
    Return,
    Call {
        function: FuncIdx,
    },
    CallIndirect {
        type_idx: TypeIdx,
        table_idx: TableIdx,
    },

    // 5.4.2 Reference instructions
    RefNull {
        reftype: RefType,
    },
    RefIsNull,
    RefFunc {
        index: FuncIdx,
    },

    // 5.4.3 Parametric instructions
    Drop,
    Select,
    SelectVal {
        val: Vec<ValType>,
    },

    // 5.4.4 Variable instructions
    LocalGet(LocalIdx),
    LocalSet(LocalIdx),
    LocalTee(LocalIdx),
    GlobalGet(GlobalIdx),
    GlobalSet(GlobalIdx),

    // 5.4.5 Table instructions
    TableGet {
        index: TableIdx,
    },
    TableSet {
        index: TableIdx,
    },
    TableInit {
        y: ElemIdx,
        x: TableIdx,
    },
    TableDrop {
        x: ElemIdx,
    },
    TableCopy {
        x: TableIdx,
        y: TableIdx,
    },
    TableGrow {
        x: TableIdx,
    },
    TableSize {
        x: TableIdx,
    },
    TableFill {
        x: TableIdx,
    },

    // 5.4.6 Memory instructions
    Load {
        numtype: NumType,
        memarg: MemArg,
    },
    Load8 {
        numtype: NumType,
        memarg: MemArg,
        signedness: Signedness,
    },
    Load16 {
        numtype: NumType,
        memarg: MemArg,
        signedness: Signedness,
    },
    Load32 {
        // load32 is always i64
        // numtype: NumType,
        memarg: MemArg,
        signedness: Signedness,
    },
    Store {
        numtype: NumType,
        memarg: MemArg,
    },
    Store8 {
        numtype: NumType,
        memarg: MemArg,
    },
    Store16 {
        numtype: NumType,
        memarg: MemArg,
    },
    Store32 {
        numtype: NumType,
        memarg: MemArg,
    },
    MemorySize,
    MemoryGrow,
    MemoryInit {
        index: DataIdx,
    },
    DataDrop {
        index: DataIdx,
    },
    MemoryCopy,
    MemoryFill,

    // Numeric instructions
    I32Const(i32),
    I64Const(i64),
    F32Const(f32),
    F64Const(f64),

    I32EqualZero,
    I32Equals,
    I32NotEquals,
    I32LessThanSigned,
    I32LessThanUnsigned,
    I32GreaterThanSigned,
    I32GreaterThanUnsigned,
    I32LessOrEqualToSigned,
    I32LessOrEqualToUnsigned,
    I32GreaterOrEqualToSigned,
    I32GreaterOrEqualToUnsigned,

    I64EqualZero,
    I64Equals,
    I64NotEquals,
    I64LessThanSigned,
    I64LessThanUnsigned,
    I64GreaterThanSigned,
    I64GreaterThanUnsigned,
    I64LessOrEqualToSigned,
    I64LessOrEqualToUnsigned,
    I64GreaterOrEqualToSigned,
    I64GreaterOrEqualToUnsigned,

    F32Equals,
    F32NotEquals,
    F32LessThan,
    F32GreaterThan,
    F32LessOrEqualTo,
    F32GreaterOrEqualTo,

    F64Equals,
    F64NotEquals,
    F64LessThan,
    F64GreaterThan,
    F64LessOrEqualTo,
    F64GreaterOrEqualTo,

    I32CountLeadingZeroBits,
    I32CountTrailingZeroBits,
    I32CountNonZeroBits,
    I32Add,
    I32Sub,
    I32Mul,
    I32DivSigned,
    I32DivUnsigned,
    I32RemainderSigned,
    I32RemainderUnsigned,
    I32LogicalAnd,
    I32LogicalOr,
    I32LogicalXor,
    I32ShiftLeft,
    I32ShiftRightSigned,
    I32ShiftRightUnsigned,
    I32RotateLeft,
    I32RotateRight,

    I64CountLeadingZeroBits,
    I64CountTrailingZeroBits,
    I64CountNonZeroBits,
    I64Add,
    I64Sub,
    I64Mul,
    I64DivSigned,
    I64DivUnsigned,
    I64RemainderSigned,
    I64RemainderUnsigned,
    I64LogicalAnd,
    I64LogicalOr,
    I64LogicalXor,
    I64ShiftLeft,
    I64ShiftRightSigned,
    I64ShiftRightUnsigned,
    I64RotateLeft,
    I64RotateRight,

    F32Abs,
    F32Neg,
    F32Ceil,
    F32Floor,
    F32Trunc,
    F32Nearest,
    F32Sqrt,
    F32Add,
    F32Sub,
    F32Mul,
    F32Div,
    F32Min,
    F32Max,
    F32CopySign,

    F64Abs,
    F64Neg,
    F64Ceil,
    F64Floor,
    F64Trunc,
    F64Nearest,
    F64Sqrt,
    F64Add,
    F64Sub,
    F64Mul,
    F64Div,
    F64Min,
    F64Max,
    F64CopySign,

    I32WrapI64,
    I32TruncF32Signed,
    I32TruncF32Unsigned,
    I32TruncF64Signed,
    I32TruncF64Unsigned,

    I64ExtendI32Signed,
    I64ExtendI32Unsigned,
    I64TruncF32Signed,
    I64TruncF32Unsigned,
    I64TruncF64Signed,
    I64TruncF64Unsigned,

    F32ConvertI32Signed,
    F32ConvertI32Unsigned,
    F32ConvertI64Signed,
    F32ConvertI64Unsigned,
    F32DemoteF64,

    F64ConvertI32Signed,
    F64ConvertI32Unsigned,
    F64ConvertI64Signed,
    F64ConvertI64Unsigned,
    F64PromoteF32,

    I32ReinterpretAsF32,
    I64ReinterpretAsF64,
    F32ReinterpretAsI32,
    F64ReinterpretAsI64,

    I32Extend8Signed,
    I32Extend16Signed,
    I64Extend8Signed,
    I64Extend16Signed,
    I64Extend32Signed,

    Vector(VectorInstruction),
}

#[derive(Clone, Debug, PartialEq)]
pub enum VectorInstruction {
    V128Load(MemArg),
    V128Load8x8(MemArg, Signedness),
    V128Load16x4(MemArg, Signedness),
    V128Load32x2(MemArg, Signedness),
    V128Load8Splat(MemArg),
    V128Load16Splat(MemArg),
    V128Load32Splat(MemArg),
    V128Load64Splat(MemArg),
    V128Load32Zero(MemArg),
    V128Load64Zero(MemArg),
    V128Store(MemArg),
    V128Load8Lane(MemArg, LaneIdx),
    V128Load16Lane(MemArg, LaneIdx),
    V128Load32Lane(MemArg, LaneIdx),
    V128Load64Lane(MemArg, LaneIdx),
    V128Store8Lane(MemArg, LaneIdx),
    V128Store16Lane(MemArg, LaneIdx),
    V128Store32Lane(MemArg, LaneIdx),
    V128Store64Lane(MemArg, LaneIdx),
    V128Const([u8; 16]),
    I8x16Shuffle([LaneIdx; 16]),
    I8x16ExtractLane(LaneIdx, Signedness),
    I8x16ReplaceLane(LaneIdx),
    I16x8ExtractLane(LaneIdx, Signedness),
    I16x8ReplaceLane(LaneIdx),
    I32x4ExtractLane(LaneIdx),
    I32x4ReplaceLane(LaneIdx),
    I64x2ExtractLane(LaneIdx),
    I64x2ReplaceLane(LaneIdx),
    F32x4ExtractLane(LaneIdx),
    F32x4ReplaceLane(LaneIdx),
    F64x2ExtractLane(LaneIdx),
    F64x2ReplaceLane(LaneIdx),

    I8x16Swizzle,
    I8x16Splat,
    I16x8Splat,
    I32x4Splat,
    I64x2Splat,
    F32x4Splat,
    F64x2Splat,

    I8x16Equal,
    I8x16NotEqual,
    I8x16LessThan(Signedness),
    I8x16GreaterThan(Signedness),
    I8x16LessOrEqualTo(Signedness),
    I8x16GreaterOrEqualTo(Signedness),

    I16x8Equal,
    I16x8NotEqual,
    I16x8LessThan(Signedness),
    I16x8GreaterThan(Signedness),
    I16x8LessOrEqualTo(Signedness),
    I16x8GreaterOrEqualTo(Signedness),

    I32x4Equal,
    I32x4NotEqual,
    I32x4LessThan(Signedness),
    I32x4GreaterThan(Signedness),
    I32x4LessOrEqualTo(Signedness),
    I32x4GreaterOrEqualTo(Signedness),

    I64x2Equal,
    I64x2NotEqual,
    I64x2LessThan,
    I64x2GreaterThan,
    I64x2LessOrEqualTo,
    I64x2GreaterOrEqualTo,

    F32x4Equal,
    F32x4NotEqual,
    F32x4LessThan,
    F32x4GreaterThan,
    F32x4LessOrEqualTo,
    F32x4GreaterOrEqualTo,

    F64x2Equal,
    F64x2NotEqual,
    F64x2LessThan,
    F64x2GreaterThan,
    F64x2LessOrEqualTo,
    F64x2GreaterOrEqualTo,

    V128Not,
    V128And,
    V128AndNot,
    V128Or,
    V128Xor,
    V128BitSelect,
    V128AnyTrue,

    I8x16Abs,
    I8x16Neg,
    I8x16PopCnt,
    I8x16AllTrue,
    I8x16Bitmask,
    I8x16NarrowI16x8(Signedness),
    I8x16ShiftLeft,
    I8x16ShiftRight(Signedness),
    I8x16Add,
    I8x16AddSaturating(Signedness),
    I8x16Sub,
    I8x16SubSaturating(Signedness),
    I8x16Min(Signedness),
    I8x16Max(Signedness),
    I8x16Average,

    I16x8ExtAddPairWiseI8x16(Signedness),
    I16x8Abs,
    I16x8Neg,
    I16x8Q16MulrSat,
    I16x8AllTrue,
    I16x8Bitmask,
    I16x8NarrowI32x4(Signedness),
    I16x8ExtendLowI8x16(Signedness),
    I16x8ExtendHighI8x16(Signedness),
    I16x8ShiftLeft,
    I16x8ShiftRight(Signedness),
    I16x8Add,
    I16x8AddSaturating(Signedness),
    I16x8Sub,
    I16x8SubSaturating(Signedness),
    I16x8Mul,
    I16x8Min(Signedness),
    I16x8Max(Signedness),
    I16x8Average(Signedness),
    I16x8ExtMulLowI8x16(Signedness),
    I16x8ExtMulHighI8x16(Signedness),

    I32x4ExtAddPairwiseI16x8(Signedness),
    I32x4Abs,
    I32x4Neg,
    I32x4AllTrue,
    I32x4Bitmask,
    I32x4ExtendLowI16x8(Signedness),
    I32x4ExtendHighI16x8(Signedness),
    I32x4ShiftLeft,
    I32x4ShiftRight(Signedness),
    I32x4Add,
    I32x4Sub,
    I32x4Mul,
    I32x4Min(Signedness),
    I32x4Max(Signedness),
    I32x4DotI16x8,
    I32x4ExtMulLowI16x8(Signedness),
    I32x4ExtMulHighI16x8(Signedness),

    I64x2Abs,
    I64x2Neg,
    I64x2AllTrue,
    I64x2Bitmask,
    I64x2ExtendLowI32x4(Signedness),
    I64x2ExtendHighI32x4(Signedness),
    I64x2ShiftLeft,
    I64x2ShiftRight(Signedness),
    I64x2Add,
    I64x2Sub,
    I64x2Mul,
    I64x2ExtMulLowI32x4(Signedness),
    I64x2ExtMulHighI32x4(Signedness),

    F32x4Ceil,
    F32x4Floor,
    F32x4Trunc,
    F32x4Nearest,
    F32x4Abs,
    F32x4Neg,
    F32x4Sqrt,
    F32x4Add,
    F32x4Sub,
    F32x4Mul,
    F32x4Div,
    F32x4Min,
    F32x4Max,
    F32x4PMin,
    F32x4PMax,

    F64x2Ceil,
    F64x2Floor,
    F64x2Trunc,
    F64x2Nearest,
    F64x2Abs,
    F64x2Neg,
    F64x2Sqrt,
    F64x2Add,
    F64x2Sub,
    F64x2Mul,
    F64x2Div,
    F64x2Min,
    F64x2Max,
    F64x2PMin,
    F64x2PMax,

    I32x4TruncSatF32x4(Signedness),
    F32x4ConvertI32x4(Signedness),
    I32x4TruncSatF64x2Zero(Signedness),
    F64x2ConvertLowI32x4(Signedness),
    F32x4DemoteF64x2Zero,
    F64x2PromoteLowF32x4,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, Default)]
#[repr(transparent)]
pub struct LaneIdx(pub u8);

#[test]
fn instruction_size() {
    assert_eq!(core::mem::size_of::<Instruction>(), 72);
    assert_eq!(core::mem::size_of::<LaneIdx>(), 8);
}
